      *=====================================================================
      *  RPG ILE MODULE SYSPED/ESTKUPLOAD
      *
      *  After compiling this RPG MODULE,
      *  create the related program with the following command:
      *
CRTPG+*  CRTPGM SYSPED/ESTKUPLOAD MODULE(*LIBL/ESTKUPLOAD
CRTPGM*         *LIBL/INCGI) ACTGRP(*NEW) AUT(*USE)
********************************************************************
      * RETTINGER I DETTE PROGRAM:
PTFnr:*Sek Sig Vers  Beskrivelse...........................
""""""*"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
10XXX * 01 JOV PTF11 Fast navnestruktur fra TKsmart -Flytt til syspeddev/signatur/Bilde..
10XXX * 02 JOV PTF11 LOGGfiler fra TKsmart -Flytt til '/syspeddev/TKsmartLog/'
10XXX * 03 JOV PTF11 bevar fullt filename
********************************************************************
      *=====================================================================
      /copy syspeds/qrpgsrcpy,hspecs
      /copy syspeds/qrpgsrcpy,hspecsbnd
     FBRIDF     UF   E           K DISK    USROPN
      /copy syspeds/qrpgsrcpy,prototypeb
      /copy syspeds/qrpgsrcpy,usec
      *=================================
     D WSUSER          S             10
     D Fn              s             10
     D Lib             s             10
     D Mbr             s             10
     D lng             s              2
     D KEY13           S             43A
     D NBRVARS         S             10i 0
     Dsavedquerystring...
     D                 s          32767    varying
      *=================================
      * VARIABLES TO CONTROL INPUT FILE
     D InDta           s          32767    based(InDtaP)
     D InDtaLn         s             10i 0
     D RspLn           s             10i 0
     D SaveP           s               *
     D StrOfDtaP       s               *
     D CvtDtaArr       s              1a   dim(1000)
     D CvtDta          s           1000a
     D CvtDtaLn        s             10i 0
     D PartSepLn       s             10i 0
     D FileSize        s             10i 0
     D FileName        s            512a
     D ServerFile      s            500a
     D ServerPath      s            500a
     D FileType        s            100a
     D FileStrPos      s             10i 0
      *=================================
      * VARIABLES FOR IFS "STAT" FUNCTION
      * Buffer for IFS stat function
     D StatusBuffer    ds                  align
     D  StsPermissions...
     D                               10u 0
     D  StsFileID                    10u 0
     D  StsLinkCount                  5u 0
     D  StsUserIDNbr                 10u 0
     D  StsGroupIdNbr                10u 0
     D  StsBytesInFile...
     D                               10i 0
     D  StsTimeLastAcc...
     D                               10i 0
     D  StsTimeLastChg...
     D                               10i 0
     D  StsTimeStsLastChg...
     D                               10i 0
     D  StsFileSysID                 10u 0
     D  StsBlockSize                 10u 0
     D  StsAllocBytes                10u 0
     D  StsObjectType                11
     D  StsCodePage                   5u 0
     D                               62
     D  StsGenerationID...
     D                               10u 0
     D  CodePage       s             10u 0 inz(819)
     D FileHandle      s             10i 0
     D ErrNoRet        s             10i 0
      *=================================
      * VARIABLES TO CHECK AN IFS FILE
     D rc              s             10i 0 inz(0)
     D ThisSubProc     c                   'ESTKUPLOAD: '
      *=================================
      * VARIABLES TO PROVIDE USER RESPONSE
     D DoneSW          s              1a
      *=================================
      * VARIABLES TO HANDLE MESSAGES
     D ErrorType       s             10i 0
     D  msg1           s           1600a
     D  msg2           s           1600a
     D  msg3           s           1600a
     D  msg4           s           1600a
     D  msg5           s           1600a
     D                 DS
     D msg                     1   1600
     D msgid                   1      7
     D msgsev                  8      9
     D msgtxt1                10    521
     D msgtxt2               522   1600
      *=================================
      * MISCELLANEOUS VARIABLES
     D EOR             s              2a   inz(x'0D25')
     D key1            s             55a
     D key2            s             13a   inz('Content-Type:')
     D UserName        s            512a
     D Cmd             s           1024a
     D LenKey1         s             10i 0
     D DlyNbr          s             10i 0
     D i               s             10i 0
     D j               s             10i 0
     D k               s             10i 0
     D l               s             10i 0
     D m               s             10i 0
     D r               s             10i 0
     D s               s             10i 0
     D t               s             10i 0
     D x               s             10i 0
     D y               s             10i 0
      *=================================
      * VARIABLES FOR PROGRAM STATUS SUBROUTINE
     D psds           sds
     D  psdsdata                    429
     D pssrswitch      s              1    inz(*off)
     D wrotetop        s              1    inz(*off)
      *===========================================
      * PART 0- PROLOG
      *===========================================
      * Initialize search keys
     C                   eval      key1 = 'Content-Disposition: form-data;' +
     C                             ' name="file"; filename="'
     C                   EVAL      KEY13 = 'Content-Disposition: form-data;' +
     C                             ' name="USER"'
      * Get externally described HTML, start response
     C                   eval      Lib = '*LIBL'
     C                   eval      Fn  = 'HTMLSRC'
     C                   eval      Mbr = 'ESTKUPLOAD'
     C                   callp     gethtml(fn:lib:mbr:'/CGITAG/')
     C                   callp     wrtsection('top')
     C                   eval      wrotetop = *on
      * Retrieve logged-in user name (if protection active)
     C                   eval      UserName = getenv('REMOTE_USER':qusec)
      *====================================================================
      * PART 1 - ASK USER INPUT
      *====================================================================
      * Get content length
     C                   eval      InDtaLn = contlen
     C                   if        InDtaLn = 0
     C                   eval      nbrVars =
     C                             zhbgetinput(SAVEDQUERYSTRING:qusec)
     C                   eval      WSUSER = zhbgetvar('USER')
     C                   callp     wrtsection('step1')
     C                   exsr      Exit
     C                   endif
     C*                  callp     wrtsection('step1')
      *====================================================================
      * PART 2- ALLOCATE STORAGE TO RECEIVE INPUT
      *         RECEIVE INPUT
      *====================================================================
      * Allocate storage for content-length bytes.  Save pointer.
     C                   alloc(e)  InDtaLn       InDtaP
     C                   if        InDtaP = *null
     C                   exsr      AllocErr
     C                   endif
     C                   eval      SaveP = InDtaP
      * Read standard input using API instead of any of ESTKUPLOAD's
      * getinput because length can easily be larger than getinput's
      * maximum buffer size of 32767.
     C                   callb     'QtmhRdStin'
     C                   parm                    InDta
     C                   parm                    InDtaLn
     C                   parm                    RspLn
     C                   parm                    qusec
      *====================================================================
      * PART 3 -  DETAIL ANALYSIS OF INPUT DATA
      *====================================================================
      * Convert initial input data to EBCDIC
      *   - establish the length of the data to be copied
     C                   eval      CvtDtaLn = %len(CvtDta)
     C                   if        InDtaLn < CvtDtaLn
     C                   eval      CvtDtaLn = InDtaLn
     C                   endif
     C                   if        CvtDtaLn > 1000
     C                   eval      CvtDtaLn = 1000
     C                   endif
      *   - copy "InDta" to "CvtDta" one byte at a time
      *     (need to move the pointer "InDtaP")
     C                   eval      i = 1
     C                   dow       i <= CvtDtaLn
     C                   eval      CvtDtaArr(i) = %subst(InDta:1:1)
     C                   eval      InDtaP = InDtaP + 1
     C                   eval      i = i +1
     C                   enddo
     C                   movea     CvtDtaArr     CvtDta
      *   - restore the pointer "InDtaP" to its initial value
     C                   eval      InDtaP = SaveP
      *   - convert "CvtDta" contents from ASCII to EBCDIC
     C                   eval      CvtDta = xlatwCCSIDS(*on:CvtDta)
      * Retrieve control data:
      *  1-path and name of the local file to be uploaded
     C                   eval      LenKey1 = %len(key1)
     C                   eval      r = %scan(key1:CvtDta)
     C                   if        r>0
     C                   eval      s = %scan(EOR:CvtDta:r)
     C                   eval      FileName = %subst(CvtDta:
     C                             r + %len(key1):
     C                             s - (r + %len(key1))-1)
     C                   endif
      *  2-type of the local file to be uploaded
     C                   eval      r = %scan(key2:CvtDta)
     C                   if        r>0
     C                   eval      s = %scan(EOR:CvtDta:r)
     C                   eval      FileType = %subst(CvtDta:
     C                             r + %len(key2):
     C                             s - (r + %len(key2)))
     C                   endif
      *  3-start position (in the buffer) of the file to be uploaded
     C                   eval      FileStrPos = s +4
      * TEST BRUKER-ID OG USERSPACENAME
     C                   eval      r = %scan(KEY13:CvtDta)
     C                   if        r>0
     C                   eval      s = %scan(EOR:CvtDta:r+%len(KEY13)+4)
     C                   eval      WSUSER = %subst(CvtDta:
     C                             r + %len(KEY13) + 4:
     C                             s - (r + %len(KEY13))-4)
     C                   endif
      *
      *  4a-length of part separator "------------------..."
     C                   eval      PartSepLn = %scan(EOR:CvtDta)
      *  4b-size of the file to be uploaded
     C                   eval      FileSize = InDtaLn - FileStrPos -
     C                             PartSepLn -4
      *====================================================================
      * PART 5 - COPY INPUT FILE TO SREAM FILE
      *=====================================================================
      *  5-path and name of the server IFS file to be created
     C                   eval      ServerPath = '/sysca/BILDER/'
     C                   IF        WSUSER   <> *BLANKS
     C                   EVAL      RC = DOCMD('OVRDBF FILE(BRIDF) +
     C                             TOFILE(*LIBL/BRIDF) SECURE(*YES)')
     C                   open      BRIDF                                50
     c     WSUSER        Chain     BRIDF                              55
     C                   CLOSE     BRIDF                                50
     c     *IN55         ifeq      *off
     C     BILIBL        ifeq      *blanks
     C                   callb     'INCGI'
     C                   parm                    BISTDL
     C                   else
     C                   call      BILIBL
     C                   end
      * hent param - primært user / sekundært firma
     C                   end
     C                   END
     C                   IF        FILENAME <> *BLANKS
     C                   eval      ServerFile= %trim(ServerPath)+%trim(filename)
N01   * fil fra TKsmart med fast struktur (foreløpig kun en pr type) senere m index 33:2 (_0, _1..)
N01   * eks: COL_0086_0002049_20150317T092245_0.jpg
N01   *      POD_0080_0201448_20150316T230508_0.jpg
N02  c                   if        %subst(filename:1:4) = 'Log_'
N02  C                   eval      ServerFile= '/syspeddev/TKsmartLog/'
S02  c*                            +%subst(filename:1:16)+'.txt'
N03  c                             +filename
N02  c                   else
N01  c                   if        %subst(filename:4:1) = '_'
N01  C                   eval      ServerFile= '/syspeddev/signatur/Bilde_'
s03  c*                            +%subst(filename:1:16)+'.jpg'
N03  c                             +filename
N01  c                   endif
N02  c                   endif
     C                   exsr      WrtDta
     C                   END
      *=====================================================================
      * PART 6 - PROVIDE USER RESPONSE
      *=====================================================================
      * Write out the input file information
     C                   callp     UpdHTMLVar('USER':WSUSER)
     C                   callp     wrtsection('step1')
     C                   callp     UpdHTMLVar('filename':FileName)
     C                   callp     UpdHTMLVar('filetype':FileType)
     C                   callp     UpdHTMLVar('filesize':
     C                             %trim(%editc(FileSize:'J')))
     C                   callp     wrtsection('strresult')
      * Display result of operation
     C                   callp     updhtmlvar('serverfile':ServerFile)
     C                   if        doneSW = 'Y'
     C                   callp     wrtsection('done')
     C                   else
     C                   callp     wrtsection('notdone')
     C                   exsr      DspErrMsg
     C                   endif
     C                   callp     wrtsection('donee')
      *
     C                   exsr      Exit
      *=====================================================================
      * Back to caller
      *=====================================================================
     C     Exit          begsr
      * Close html and send buffer
     C                   callp     wrtsection('endhtml *fini')
      * Back to caller
     C                   eval      *inlr = *on
     C                   return
     C                   endsr
      *=====================================================================
      * Create and write the IFS output file
      *=====================================================================
     C     WrtDta        begsr
      * Assume it fails
     C                   eval      DoneSW = 'N'
     C                   eval      ErrorType = 0
      * Unlink (delete) the file if it already exists.
     C                   eval      dlynbr = 0
     C                   dow       stat(%trim(ServerFile):
     C                             %addr(StatusBuffer)) = 0
     C                   eval      rc = unlink(%trim(ServerFile))
     C                   if        rc <> 0
     C                   eval      dlynbr = dlynbr +1
     C                   if        dlynbr > 5
     C                   leave
     C                   endif
     C                   eval      rc = docmd('dlyjob 10')
     C                   endif
     C                   enddo
      * Open stream file
     C                   eval      FileHandle = open(%trim(ServerFile):
     C                             O_CREAT + O_WRONLY +
     C                             O_TRUNC + O_TEXTDATA + O_CODEPAGE:
     C                             S_IRWXU + S_IROTH + S_IXOTH:CodePage)
     C                   if        FileHandle = -1
     C                   eval      ErrNoRet = errno
     C                   eval      msg1 = ThisSubProc + 'Open of IFS file ' +
     C                             %trim(ServerFile) +
     C                             ' failed.  Message text is ' +
     C                             errnotxt(ErrNoRet)
     C                   callp     wrtdebug(msg1:*on)
     C                   eval      ErrorType = 1
     C                   goto      WrtDtaX
     C                   endif
      * Write buffer to the streamfile
     C                   eval      StrOfDtaP = InDtaP + FileStrPos -1
     C                   eval      rc = write(FileHandle:
     C                             StrOfDtaP:FileSize)
     C                   if        rc = -1
     C                   eval      ErrNoRet = errno
     C                   eval      msg1 = ThisSubProc + 'Write into IFS -
     C                             file ' + %trim(ServerFile) +
     C                             ' failed.  Message text is ' +
     C                             errnotxt(ErrNoRet)
     C                   callp     wrtdebug(msg1:*on)
     C                   eval      ErrorType = 3
     C                   goto      WrtDtaX
     C                   endif
      * Close streamfile
     C                   eval      rc = close(FileHandle)
     C                   if        rc = -1
     C                   eval      ErrNoRet = errno
     C                   eval      msg1 = ThisSubProc + 'Close of IFS file '+
     C                             %trim(ServerFile) +
     C                             ' failed.  Message text is ' +
     C                             errnotxt(ErrNoRet)
     C                   callp     wrtdebug(msg1:*on)
     C                   eval      ErrorType = 2
     C                   goto      WrtDtaX
     C                   endif
      * File was correctly created and written
     C                   eval      DoneSW = 'Y'
      *
     C     WrtDtaX       tag
     C                   endsr
      *====================================================================
      * Memory allocation error
      *====================================================================
     C     AllocErr      begsr
     C                   callp     updhtmlvar('indtaln':
     C                             %editc(InDtaLn:'J'))
     C                   callp     wrtsection('allocerr')
     C                   exsr      Exit
     C                   endsr
      *====================================================================
      * Display error messages
      *====================================================================
     C     DspErrMsg     begsr
     C                   eval      msg = msg1
     C                   exsr      MsgRow
     C                   eval      msg = msg2
     C                   exsr      MsgRow
     C                   eval      msg = msg3
     C                   exsr      MsgRow
     C                   eval      msg = msg4
     C                   exsr      MsgRow
     C                   eval      msg = msg5
     C                   exsr      MsgRow
     C                   endsr
      *=====================================================================
      * Issue a message row
      *=====================================================================
     C     MsgRow        begsr
     C                   IF        msgid <> ' '
     C                   callp     updhtmlvar('msgid':msgid)
     C                   callp     updhtmlvar('msgsev': msgsev)
     C                   callp     updhtmlvar('msgtxt1':msgtxt1)
     C                   eval      l = %size(msgtxt2)
      *
     C                   eval      r = %scan('&N':msgtxt2)
     C                   dow       r > 0
     C                   if        r = 1
     C                   eval      msgtxt2 = %subst(msgtxt2:3:l-2)
     C                   else
     C                   eval      msgtxt2 = %subst(msgtxt2:1:r-1) +
     C                             '<br>' + %subst(msgtxt2:r+2:l-r-1)
     C                   endif
     C                   eval      r = %scan('&N':msgtxt2)
     C                   enddo
      *
     C                   eval      r = %scan('&P':msgtxt2)
     C                   dow       r > 0
     C                   if        r = 1
     C                   eval      msgtxt2 = %subst(msgtxt2:3:l-2)
     C                   else
     C                   eval      msgtxt2 = %subst(msgtxt2:1:r-1) +
     C                             '<br>' + %subst(msgtxt2:r+2:l-r-1)
     C                   endif
     C                   eval      r = %scan('&P':msgtxt2)
     C                   enddo
      *
     C                   eval      r = %scan('&B':msgtxt2)
     C                   dow       r > 0
     C                   if        r = 1
     C                   eval      msgtxt2 = %subst(msgtxt2:3:l-2)
     C                   else
     C                   eval      msgtxt2 = %subst(msgtxt2:1:r-1) +
     C                             '<li>' + %subst(msgtxt2:r+2:l-r-1)
     C                   endif
     C                   eval      r = %scan('&B':msgtxt2)
     C                   enddo
      *
     C                   callp     updhtmlvar('msgtxt2':msgtxt2)
     C                   callp     wrtsection('msgrow1')
     C                   if        msgtxt2 <> ' '
     C                   callp     wrtsection('msgrow2')
     C                   endif
     C                   ENDIF
     C                   endsr
      *=====================================================================
      * PROGRAM STATUS SUBROUTINE
      *=====================================================================
     C     *pssr         begsr
     C                   if        pssrswitch=*on
     C                   eval      *inlr = *on
     C                   return
     C                   endif
     C                   eval      pssrswitch=*on
     C                   if        wrotetop=*off
     C                   callp     wrtsection('top')
     C                   endif
     C                   callp     wrtsection('pssr *fini')
     C                   callp     wrtpsds(psds)
     C                   eval      *inlr = *on
     C                   return
     C                   endsr
